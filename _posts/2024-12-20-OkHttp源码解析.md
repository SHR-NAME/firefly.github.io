## 优点

1、支持 HTTP/1.1、HTTP/2、WebSocket 等协议，能够满足不同的网络需求  
2、使用连接池（Connection Pool）来重用连接，从而降低延迟，提高请求效率    
3、允许用户自定义拦截器（Interceptor），可以在请求和响应的生命周期中进行处理，满足特定的需求   
4、OkHttp 支持缓存机制，可以有效减少网络请求次数，降低服务器压力，并节省流量。  
5、GZIP压缩，自动使用 GZIP 压缩技术来减少数据传输的大小。

另外还有 简洁的API、异步请求、TLS支持等优点

对于OkHttp,我们可以学习到线程池的具体使用、责任链模式的具体应用。以下从两个方面展开解释说明；

## 线程池

通常对于线程池的理解在于，我们会根据如下步骤进行处理：

1. 任务数 <= 核心线程数，会开启新的线程处理任务
2. 任务数 > 核心线程数，会将任务放入队列当中，当有空闲线程可用时，复用线程处理任务。
3. 队列满 ，会根据最大线程数来进行处理 ，即 线程数<= 最大线程数
   ，新创建线程开始处理当队列满且线程数小于最大线程数时，新创建的线程会优先处理新提交的任务，而不是优先处理队列中已有的任务。
4. 当 线程数 > 最大线程数 时，会根据拒绝策略进行处理。

举例：假设你有一个线程池，核心线程数为2，最大线程数为 5，任务队列大小为10。这时有10 个任务，线程池首先会开启两个线程处理
任务1和2，然后会把其余的8个任务放入任务队列里边，等待处理。同样的情况 适用于 任务数 <= 核心数 + 任务队列容量。当任务数大于12时候
就会触发创建新的线程处理新的任务，队列中的任务由之前的线程进行等待处理。假设任务数超过15时候，就会触发拒绝策略。

NOTE: 核心线程数如果为0的时候是怎么处理的？   
核心线程数=0会将任务加入到任务队列中，然后开启工作线程进行处理，只要任务数<=
队列容量，就只会有一个线程进行处理，如果任务数 > 队列容量，才会
触发创建新的线程，直到达到最大线程数，当任务数 > 队列容量 + 最大线程数 时，会执行拒绝策略；

## 责任链模式

okhttp 设计的精妙之处，可以让用户自定义添加各种拦截器，来处理Request和Response。
![interceptors](/assets/okhttp_interceptors.png)

从图上可以看出拦截器的执行流程，在Netty中的PipeLine中我们也可以看到类似的设计。

如何实现？

1. 定义接口 Interceptor ，方法 intercept。
2. 定义接口 Chain， 方法 process
3. 实现Chain，并在process方法中，进行拦截器的流转，具体是通过index(索引)来实现。
